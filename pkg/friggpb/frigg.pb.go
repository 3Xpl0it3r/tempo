// Code generated by protoc-gen-go. DO NOT EDIT.
// source: frigg.proto

/*
Package friggpb is a generated protocol buffer package.

It is generated from these files:
	frigg.proto

It has these top-level messages:
	Trace
	PushRequest
	PushResponse
	Span
	Process
	KeyValuePair
	Status
*/
package friggpb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type KeyValuePair_ValueType int32

const (
	KeyValuePair_STRING KeyValuePair_ValueType = 0
	KeyValuePair_INT    KeyValuePair_ValueType = 1
	KeyValuePair_DOUBLE KeyValuePair_ValueType = 2
	KeyValuePair_BOOL   KeyValuePair_ValueType = 3
)

var KeyValuePair_ValueType_name = map[int32]string{
	0: "STRING",
	1: "INT",
	2: "DOUBLE",
	3: "BOOL",
}
var KeyValuePair_ValueType_value = map[string]int32{
	"STRING": 0,
	"INT":    1,
	"DOUBLE": 2,
	"BOOL":   3,
}

func (x KeyValuePair_ValueType) String() string {
	return proto.EnumName(KeyValuePair_ValueType_name, int32(x))
}
func (KeyValuePair_ValueType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

// todo:  defining a Trace as a bunch of push requests seems dumb-ish.  rename push request to "batch"?
type Trace struct {
	Batches []*PushRequest `protobuf:"bytes,1,rep,name=batches" json:"batches,omitempty"`
}

func (m *Trace) Reset()                    { *m = Trace{} }
func (m *Trace) String() string            { return proto.CompactTextString(m) }
func (*Trace) ProtoMessage()               {}
func (*Trace) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Trace) GetBatches() []*PushRequest {
	if m != nil {
		return m.Batches
	}
	return nil
}

type PushRequest struct {
	Spans   []*Span  `protobuf:"bytes,1,rep,name=spans" json:"spans,omitempty"`
	Process *Process `protobuf:"bytes,2,opt,name=process" json:"process,omitempty"`
}

func (m *PushRequest) Reset()                    { *m = PushRequest{} }
func (m *PushRequest) String() string            { return proto.CompactTextString(m) }
func (*PushRequest) ProtoMessage()               {}
func (*PushRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *PushRequest) GetSpans() []*Span {
	if m != nil {
		return m.Spans
	}
	return nil
}

func (m *PushRequest) GetProcess() *Process {
	if m != nil {
		return m.Process
	}
	return nil
}

type PushResponse struct {
}

func (m *PushResponse) Reset()                    { *m = PushResponse{} }
func (m *PushResponse) String() string            { return proto.CompactTextString(m) }
func (*PushResponse) ProtoMessage()               {}
func (*PushResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type Span struct {
	TraceID      []byte                   `protobuf:"bytes,1,opt,name=traceID,proto3" json:"traceID,omitempty"`
	SpanID       []byte                   `protobuf:"bytes,2,opt,name=spanID,proto3" json:"spanID,omitempty"`
	ParentSpanID []byte                   `protobuf:"bytes,3,opt,name=parentSpanID,proto3" json:"parentSpanID,omitempty"`
	Name         string                   `protobuf:"bytes,5,opt,name=name" json:"name,omitempty"`
	StartTime    int64                    `protobuf:"varint,6,opt,name=startTime" json:"startTime,omitempty"`
	Duration     int32                    `protobuf:"varint,7,opt,name=duration" json:"duration,omitempty"`
	Status       *Status                  `protobuf:"bytes,8,opt,name=status" json:"status,omitempty"`
	Events       map[string]*KeyValuePair `protobuf:"bytes,9,rep,name=events" json:"events,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Tags         map[string]*KeyValuePair `protobuf:"bytes,10,rep,name=tags" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Span) Reset()                    { *m = Span{} }
func (m *Span) String() string            { return proto.CompactTextString(m) }
func (*Span) ProtoMessage()               {}
func (*Span) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Span) GetTraceID() []byte {
	if m != nil {
		return m.TraceID
	}
	return nil
}

func (m *Span) GetSpanID() []byte {
	if m != nil {
		return m.SpanID
	}
	return nil
}

func (m *Span) GetParentSpanID() []byte {
	if m != nil {
		return m.ParentSpanID
	}
	return nil
}

func (m *Span) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Span) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *Span) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Span) GetStatus() *Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Span) GetEvents() map[string]*KeyValuePair {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *Span) GetTags() map[string]*KeyValuePair {
	if m != nil {
		return m.Tags
	}
	return nil
}

type Process struct {
	Name string                   `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Tags map[string]*KeyValuePair `protobuf:"bytes,2,rep,name=tags" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Process) Reset()                    { *m = Process{} }
func (m *Process) String() string            { return proto.CompactTextString(m) }
func (*Process) ProtoMessage()               {}
func (*Process) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Process) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Process) GetTags() map[string]*KeyValuePair {
	if m != nil {
		return m.Tags
	}
	return nil
}

// from opencensus proto
type KeyValuePair struct {
	Key  string                 `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Type KeyValuePair_ValueType `protobuf:"varint,2,opt,name=type,enum=friggpb.KeyValuePair_ValueType" json:"type,omitempty"`
	// Only one of the following fields is supposed to contain data (determined by `type` field).
	// This is deliberately not using Protobuf `oneof` for performance reasons (verified by benchmarks).
	StringValue string  `protobuf:"bytes,3,opt,name=string_value,json=stringValue" json:"string_value,omitempty"`
	IntValue    int64   `protobuf:"varint,4,opt,name=int_value,json=intValue" json:"int_value,omitempty"`
	DoubleValue float64 `protobuf:"fixed64,5,opt,name=double_value,json=doubleValue" json:"double_value,omitempty"`
	BoolValue   bool    `protobuf:"varint,6,opt,name=bool_value,json=boolValue" json:"bool_value,omitempty"`
}

func (m *KeyValuePair) Reset()                    { *m = KeyValuePair{} }
func (m *KeyValuePair) String() string            { return proto.CompactTextString(m) }
func (*KeyValuePair) ProtoMessage()               {}
func (*KeyValuePair) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *KeyValuePair) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KeyValuePair) GetType() KeyValuePair_ValueType {
	if m != nil {
		return m.Type
	}
	return KeyValuePair_STRING
}

func (m *KeyValuePair) GetStringValue() string {
	if m != nil {
		return m.StringValue
	}
	return ""
}

func (m *KeyValuePair) GetIntValue() int64 {
	if m != nil {
		return m.IntValue
	}
	return 0
}

func (m *KeyValuePair) GetDoubleValue() float64 {
	if m != nil {
		return m.DoubleValue
	}
	return 0
}

func (m *KeyValuePair) GetBoolValue() bool {
	if m != nil {
		return m.BoolValue
	}
	return false
}

type Status struct {
	Code    int32  `protobuf:"varint,1,opt,name=code" json:"code,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
}

func (m *Status) Reset()                    { *m = Status{} }
func (m *Status) String() string            { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()               {}
func (*Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Status) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Status) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterType((*Trace)(nil), "friggpb.Trace")
	proto.RegisterType((*PushRequest)(nil), "friggpb.PushRequest")
	proto.RegisterType((*PushResponse)(nil), "friggpb.PushResponse")
	proto.RegisterType((*Span)(nil), "friggpb.Span")
	proto.RegisterType((*Process)(nil), "friggpb.Process")
	proto.RegisterType((*KeyValuePair)(nil), "friggpb.KeyValuePair")
	proto.RegisterType((*Status)(nil), "friggpb.Status")
	proto.RegisterEnum("friggpb.KeyValuePair_ValueType", KeyValuePair_ValueType_name, KeyValuePair_ValueType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Pusher service

type PusherClient interface {
	Push(ctx context.Context, in *PushRequest, opts ...grpc.CallOption) (*PushResponse, error)
}

type pusherClient struct {
	cc *grpc.ClientConn
}

func NewPusherClient(cc *grpc.ClientConn) PusherClient {
	return &pusherClient{cc}
}

func (c *pusherClient) Push(ctx context.Context, in *PushRequest, opts ...grpc.CallOption) (*PushResponse, error) {
	out := new(PushResponse)
	err := grpc.Invoke(ctx, "/friggpb.Pusher/Push", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Pusher service

type PusherServer interface {
	Push(context.Context, *PushRequest) (*PushResponse, error)
}

func RegisterPusherServer(s *grpc.Server, srv PusherServer) {
	s.RegisterService(&_Pusher_serviceDesc, srv)
}

func _Pusher_Push_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PusherServer).Push(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/friggpb.Pusher/Push",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PusherServer).Push(ctx, req.(*PushRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Pusher_serviceDesc = grpc.ServiceDesc{
	ServiceName: "friggpb.Pusher",
	HandlerType: (*PusherServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Push",
			Handler:    _Pusher_Push_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "frigg.proto",
}

func init() { proto.RegisterFile("frigg.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 590 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x54, 0xdd, 0x6e, 0xd4, 0x3c,
	0x10, 0xad, 0x37, 0xd9, 0x64, 0x33, 0xc9, 0xd7, 0x2f, 0xb2, 0x28, 0x84, 0x05, 0x44, 0x1a, 0x2e,
	0x88, 0xa8, 0x14, 0x89, 0xad, 0x28, 0x88, 0x1b, 0xa4, 0xaa, 0x15, 0x5a, 0x51, 0xb5, 0x95, 0x1b,
	0xb8, 0x04, 0x79, 0xb7, 0x26, 0x8d, 0x68, 0x93, 0x10, 0x3b, 0x95, 0xf6, 0x29, 0x78, 0x02, 0x1e,
	0x8b, 0xf7, 0x41, 0xfe, 0xd9, 0x74, 0x5b, 0xf6, 0xb2, 0x77, 0x33, 0xe7, 0x1c, 0x1f, 0xdb, 0x33,
	0x63, 0x83, 0xff, 0xbd, 0x2d, 0x8b, 0x22, 0x6b, 0xda, 0x5a, 0xd4, 0xd8, 0x55, 0x49, 0x33, 0x4b,
	0xde, 0xc2, 0x30, 0x6f, 0xe9, 0x9c, 0xe1, 0x0c, 0xdc, 0x19, 0x15, 0xf3, 0x0b, 0xc6, 0x23, 0x14,
	0x5b, 0xa9, 0x3f, 0x79, 0x90, 0x19, 0x4d, 0x76, 0xda, 0xf1, 0x0b, 0xc2, 0x7e, 0x76, 0x8c, 0x0b,
	0xb2, 0x14, 0x25, 0x5f, 0xc1, 0x5f, 0xc1, 0xf1, 0x0b, 0x18, 0xf2, 0x86, 0x56, 0xcb, 0xc5, 0xff,
	0xf5, 0x8b, 0xcf, 0x1a, 0x5a, 0x11, 0xcd, 0xe1, 0x57, 0xe0, 0x36, 0x6d, 0x3d, 0x67, 0x9c, 0x47,
	0x83, 0x18, 0xa5, 0xfe, 0x24, 0xbc, 0xd9, 0x43, 0xe3, 0x64, 0x29, 0x48, 0x36, 0x21, 0xd0, 0xfe,
	0xbc, 0xa9, 0x2b, 0xce, 0x92, 0x3f, 0x16, 0xd8, 0xd2, 0x0b, 0x47, 0xe0, 0x0a, 0x79, 0xe2, 0xe9,
	0x41, 0x84, 0x62, 0x94, 0x06, 0x64, 0x99, 0xe2, 0x87, 0xe0, 0xc8, 0x7d, 0xa6, 0x07, 0xca, 0x3d,
	0x20, 0x26, 0xc3, 0x09, 0x04, 0x0d, 0x6d, 0x59, 0x25, 0xce, 0x34, 0x6b, 0x29, 0xf6, 0x16, 0x86,
	0x31, 0xd8, 0x15, 0xbd, 0x62, 0xd1, 0x30, 0x46, 0xa9, 0x47, 0x54, 0x8c, 0x9f, 0x82, 0xc7, 0x05,
	0x6d, 0x45, 0x5e, 0x5e, 0xb1, 0xc8, 0x89, 0x51, 0x6a, 0x91, 0x1b, 0x00, 0x8f, 0x61, 0x74, 0xde,
	0xb5, 0x54, 0x94, 0x75, 0x15, 0xb9, 0x31, 0x4a, 0x87, 0xa4, 0xcf, 0xf1, 0x4b, 0x70, 0xb8, 0xa0,
	0xa2, 0xe3, 0xd1, 0x48, 0xdd, 0xf3, 0xff, 0x9b, 0x72, 0x28, 0x98, 0x18, 0x1a, 0xbf, 0x06, 0x87,
	0x5d, 0xb3, 0x4a, 0xf0, 0xc8, 0x53, 0x75, 0x7b, 0x7c, 0xab, 0x6e, 0xd9, 0xa1, 0xe2, 0x0e, 0x2b,
	0xd1, 0x2e, 0x88, 0x11, 0xe2, 0x1d, 0xb0, 0x05, 0x2d, 0x78, 0x04, 0x6a, 0xc1, 0xa3, 0xdb, 0x0b,
	0x72, 0x5a, 0x18, 0xb9, 0x12, 0x8d, 0x4f, 0xc1, 0x5f, 0xf1, 0xc0, 0x21, 0x58, 0x3f, 0xd8, 0x42,
	0xd5, 0xcd, 0x23, 0x32, 0xc4, 0x3b, 0x30, 0xbc, 0xa6, 0x97, 0x1d, 0x33, 0x0d, 0xd9, 0xea, 0xed,
	0x3e, 0xb1, 0xc5, 0x17, 0x49, 0x9c, 0xd2, 0xb2, 0x25, 0x5a, 0xf3, 0x7e, 0xf0, 0x0e, 0x8d, 0x8f,
	0xc1, 0xeb, 0x37, 0xb9, 0x07, 0xbf, 0xe4, 0x37, 0x02, 0xd7, 0x34, 0xbf, 0x6f, 0x02, 0x5a, 0x69,
	0x42, 0x66, 0xae, 0x3b, 0x50, 0xd7, 0x1d, 0xdf, 0x1d, 0x98, 0x7f, 0x6e, 0x7c, 0xdf, 0xe7, 0xfb,
	0x35, 0x80, 0x60, 0x95, 0x5b, 0xe3, 0xb9, 0x0b, 0xb6, 0x58, 0x34, 0xda, 0x72, 0x73, 0xf2, 0x7c,
	0xad, 0x65, 0xa6, 0xa2, 0x7c, 0xd1, 0x30, 0xa2, 0xc4, 0x78, 0x1b, 0x02, 0x2e, 0xda, 0xb2, 0x2a,
	0xbe, 0xe9, 0xf3, 0x58, 0xca, 0xcf, 0xd7, 0x98, 0x12, 0xe3, 0x27, 0xe0, 0x95, 0x95, 0x30, 0xbc,
	0xad, 0xe6, 0x6f, 0x54, 0x56, 0x42, 0x93, 0xdb, 0x10, 0x9c, 0xd7, 0xdd, 0xec, 0x92, 0x19, 0x5e,
	0x0e, 0x2e, 0x22, 0xbe, 0xc6, 0xb4, 0xe4, 0x19, 0xc0, 0xac, 0xae, 0x2f, 0x8d, 0x40, 0x0e, 0xf0,
	0x88, 0x78, 0x12, 0x51, 0x74, 0xb2, 0x07, 0x5e, 0x7f, 0x28, 0x0c, 0xe0, 0x9c, 0xe5, 0x64, 0x7a,
	0xfc, 0x31, 0xdc, 0xc0, 0x2e, 0x58, 0xd3, 0xe3, 0x3c, 0x44, 0x12, 0x3c, 0x38, 0xf9, 0xbc, 0x7f,
	0x74, 0x18, 0x0e, 0xf0, 0x08, 0xec, 0xfd, 0x93, 0x93, 0xa3, 0xd0, 0x4a, 0xf6, 0xc0, 0xd1, 0x53,
	0x2c, 0xfb, 0x35, 0xaf, 0xcf, 0x75, 0xbf, 0x86, 0x44, 0xc5, 0xf2, 0x79, 0x5e, 0x31, 0xce, 0x69,
	0xa1, 0xeb, 0xe1, 0x91, 0x65, 0x3a, 0xf9, 0x00, 0x8e, 0x7c, 0xd1, 0xac, 0xc5, 0x6f, 0xc0, 0x96,
	0x11, 0x5e, 0xfb, 0xc5, 0x8c, 0xb7, 0xee, 0xa0, 0xe6, 0x03, 0xd8, 0x98, 0x39, 0xea, 0xef, 0xda,
	0xfd, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x3b, 0xe4, 0x79, 0xce, 0xca, 0x04, 0x00, 0x00,
}
